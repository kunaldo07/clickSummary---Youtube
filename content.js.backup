// YouTube Video Summarizer Content Script

class YouTubeSummarizer {
  constructor() {
    this.currentVideoId = null;
    this.summaryContainer = null;
    this.isProcessing = false;
    this.currentSummaryType = 'insightful'; // insightful, funny, actionable, controversial
    this.currentFormat = 'list'; // list, q&a
    this.currentLength = 'auto'; // short, auto, detailed
    this.transcriptData = null;
    this.commentsData = null;
    this.showingTranscript = false;
    this.init();
  }

  init() {
    // Wait for YouTube to load and then start monitoring
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.startMonitoring());
    } else {
      this.startMonitoring();
    }
  }

  startMonitoring() {
    // Monitor for URL changes (YouTube is a SPA)
    let lastUrl = location.href;
    new MutationObserver(() => {
      const url = location.href;
      if (url !== lastUrl) {
        lastUrl = url;
        this.onPageChange();
      }
    }).observe(document, { subtree: true, childList: true });

    // Handle initial page load
    this.onPageChange();
  }

  onPageChange() {
    const videoId = this.getVideoId();
    if (videoId && videoId !== this.currentVideoId) {
      this.currentVideoId = videoId;
      this.removePreviousSummary();
      setTimeout(() => this.procesVideo(), 2000); // Wait for YouTube to load
    }
  }

  getVideoId() {
    const url = new URL(window.location.href);
    return url.searchParams.get('v');
  }

  async procesVideo() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    try {
      this.createSummaryContainer();
      this.showLoadingState();

      // Extract both transcript and comments in parallel
      const [transcriptData, commentsData] = await Promise.all([
        this.extractTranscript(),
        this.extractTopComments()
      ]);

      this.transcriptData = transcriptData;
      this.commentsData = commentsData;

      if (transcriptData || commentsData) {
        // Generate summaries based on available data
        await this.generateAllSummaries();
        this.displayAdvancedSummary();
      } else {
        this.displayError('Neither transcript nor comments are available for this video');
      }
    } catch (error) {
      console.error('Error processing video:', error);
      this.displayError('Failed to process video: ' + error.message);
    }

    this.isProcessing = false;
  }

  async extractTranscript() {
    return new Promise((resolve) => {
      console.log('üîç YouTube Summarizer: Looking for transcript...');
      
      // First, check if transcript is already visible
      let transcriptData = this.getTranscriptSegments();
      if (transcriptData) {
        console.log('‚úÖ Found existing transcript data');
        resolve(transcriptData);
        return;
      }

      // Try to find and click transcript button
      const transcriptButton = this.findTranscriptButton();
      
      if (!transcriptButton) {
        console.log('‚ùå No transcript button found');
        resolve(null);
        return;
      }

      console.log('üéØ Found transcript button, clicking...');
      transcriptButton.click();
      
      // Wait for transcript to load with multiple attempts
      let attempts = 0;
      const maxAttempts = 5;
      
      const checkForTranscript = () => {
        attempts++;
        const transcriptSegments = this.getTranscriptSegments();
        
        if (transcriptSegments) {
          console.log('‚úÖ Transcript extracted successfully');
          resolve(transcriptSegments);
        } else if (attempts < maxAttempts) {
          console.log(`‚è≥ Attempt ${attempts}/${maxAttempts} - waiting for transcript...`);
          setTimeout(checkForTranscript, 1000);
        } else {
          console.log('‚ùå Failed to extract transcript after multiple attempts');
          resolve(null);
        }
      };
      
      setTimeout(checkForTranscript, 1500);
    });
  }

  findTranscriptButton() {
    console.log('üîç Looking for transcript button...');
    
    // Method 1: Look for transcript button by text content
    const buttons = document.querySelectorAll('button');
    for (const button of buttons) {
      const text = button.textContent.toLowerCase();
      if (text.includes('transcript') || text.includes('show transcript')) {
        console.log('üìù Found transcript button by text');
        return button;
      }
    }

    // Method 2: Look for transcript button by aria-label
    const transcriptByLabel = document.querySelector('button[aria-label*="transcript" i], button[aria-label*="Show transcript" i]');
    if (transcriptByLabel) {
      console.log('üìù Found transcript button by aria-label');
      return transcriptByLabel;
    }

    // Method 3: Look in the description area specifically
    const description = document.querySelector('#description, #meta-contents, ytd-video-secondary-info-renderer');
    if (description) {
      const descButtons = description.querySelectorAll('button');
      for (const button of descButtons) {
        const text = button.textContent.toLowerCase();
        const ariaLabel = (button.getAttribute('aria-label') || '').toLowerCase();
        if (text.includes('transcript') || ariaLabel.includes('transcript')) {
          console.log('üìù Found transcript button in description area');
          return button;
        }
      }
    }

    // Method 4: Look for three-dot menu and expand it
    const moreButton = document.querySelector('#expand, button[aria-label*="more" i]');
    if (moreButton && !moreButton.getAttribute('aria-expanded')) {
      console.log('üìã Expanding description to look for transcript');
      moreButton.click();
      
      // Wait a bit then search again
      setTimeout(() => {
        const expandedTranscript = document.querySelector('button[aria-label*="transcript" i]');
        if (expandedTranscript) {
          console.log('üìù Found transcript after expanding description');
          return expandedTranscript;
        }
      }, 500);
    }

    console.log('‚ùå No transcript button found');
    return null;
  }

  getTranscriptSegments() {
    console.log('üìù Attempting to extract transcript segments...');
    
    // Method 1: Look for individual transcript segments (proper format)
    const segmentElements = document.querySelectorAll('ytd-transcript-segment-renderer');
    if (segmentElements.length > 0) {
      console.log(`‚úÖ Found ${segmentElements.length} structured transcript segments`);
      const segments = Array.from(segmentElements).map((segmentEl, index) => {
        const timeButton = segmentEl.querySelector('div[class*="cue"] .ytd-transcript-segment-renderer');
        const textEl = segmentEl.querySelector('.segment-text, [class*="segment-text"]');
        
        // Try to extract timestamp
        let timeStr = timeButton?.textContent?.trim() || `${index * 10}s`;
        let startTime = this.parseTimeToSeconds(timeStr);
        
        // Get text content
        let text = textEl?.textContent?.trim() || segmentEl.textContent.trim();
        
        return {
          start: startTime,
          text: text,
          index: index
        };
      }).filter(segment => segment.text.length > 0);
      
      if (segments.length > 0) return segments;
    }

    // Method 2: Look for transcript segments with data-seq attribute  
    const dataSeqElements = document.querySelectorAll('[data-seq]');
    if (dataSeqElements.length > 0) {
      console.log(`‚úÖ Found ${dataSeqElements.length} transcript segments with data-seq`);
      const segments = Array.from(dataSeqElements).map((segment, index) => {
        const text = segment.textContent.trim();
        const startTime = index * 5; // Estimate 5 seconds per segment
        
        return {
          start: startTime,
          text: text,
          index: index
        };
      }).filter(segment => segment.text.length > 0);
      
      if (segments.length > 0) return segments;
    }

    // Method 3: Look for transcript container and try to extract segments
    const transcriptContainer = document.querySelector('ytd-transcript-segment-list-renderer, ytd-transcript-renderer');
    if (transcriptContainer) {
      console.log('üìã Found transcript container, looking for segments...');
      
      // Try to find individual segment elements
      const segmentSelectors = [
        'ytd-transcript-segment-renderer',
        '.ytd-transcript-segment-renderer',
        '[class*="segment"]',
        '.segment-text'
      ];
      
      for (const selector of segmentSelectors) {
        const elements = transcriptContainer.querySelectorAll(selector);
        if (elements.length > 3) { // Need multiple segments
          console.log(`‚úÖ Found segments using selector: ${selector}`);
          const segments = Array.from(elements).map((el, index) => {
            const text = el.textContent.trim();
            const startTime = index * 10; // Estimate timing
            
            return {
              start: startTime,
              text: text,
              index: index
            };
          }).filter(segment => segment.text.length > 5);
          
          if (segments.length > 0) return segments;
        }
      }
      
      // Fallback: split the full transcript text into chunks
      const fullText = transcriptContainer.textContent.trim();
      if (fullText.length > 50) {
        console.log('üìÑ Using full transcript text, splitting into segments');
        const sentences = fullText.split(/[.!?]+/).filter(s => s.trim().length > 10);
        const segments = sentences.map((sentence, index) => ({
          start: index * 8, // Estimate 8 seconds per sentence
          text: sentence.trim(),
          index: index
        }));
        
        if (segments.length > 0) return segments;
      }
    }

    // Method 4: Fallback - look for any transcript content and split it
    const allTranscriptElements = document.querySelectorAll('[class*="transcript"], [id*="transcript"]');
    for (const element of allTranscriptElements) {
      const text = element.textContent.trim();
      if (text.length > 100 && !text.includes('Transcript') && !text.includes('Show transcript')) {
        console.log('‚úÖ Found transcript text, converting to segments');
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
        const segments = sentences.slice(0, 50).map((sentence, index) => ({ // Limit to 50 segments
          start: index * 8,
          text: sentence.trim(),
          index: index
        }));
        
        if (segments.length > 0) return segments;
      }
    }

    console.log('‚ùå No transcript segments found');
    return null;
  }

  parseTimeToSeconds(timeStr) {
    if (!timeStr) return 0;
    
    // Handle formats like "1:23" or "01:23:45" or "1m 23s" 
    timeStr = timeStr.replace(/[^\d:]/g, ''); // Remove non-digits and colons
    
    const parts = timeStr.split(':').map(Number);
    let seconds = 0;
    
    if (parts.length === 1) {
      seconds = parts[0];
    } else if (parts.length === 2) {
      seconds = parts[0] * 60 + parts[1];
    } else if (parts.length === 3) {
      seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
    }
    
    return seconds;
  }

  async extractTopComments() {
    console.log('üí¨ Extracting top comments...');
    
    try {
      // Wait for comments to load
      await this.waitForComments();
      
      const comments = document.querySelectorAll('#content-text');
      const topComments = Array.from(comments)
        .slice(0, 10) // Get top 10 comments
        .map(comment => ({
          text: comment.textContent.trim(),
          author: this.getCommentAuthor(comment),
          likes: this.getCommentLikes(comment)
        }))
        .filter(comment => comment.text.length > 10); // Filter out short comments
      
      console.log(`‚úÖ Extracted ${topComments.length} comments`);
      return topComments.length > 0 ? topComments : null;
    } catch (error) {
      console.log('‚ùå Failed to extract comments:', error);
      return null;
    }
  }

  async waitForComments() {
    return new Promise((resolve) => {
      let attempts = 0;
      const maxAttempts = 10;
      
      const checkComments = () => {
        const comments = document.querySelectorAll('#content-text');
        if (comments.length > 0) {
          resolve();
        } else if (attempts < maxAttempts) {
          attempts++;
          setTimeout(checkComments, 1000);
        } else {
          resolve(); // Continue even if no comments found
        }
      };
      
      checkComments();
    });
  }

  getCommentAuthor(commentElement) {
    try {
      const authorElement = commentElement.closest('ytd-comment-thread-renderer, ytd-comment-renderer')
        ?.querySelector('#author-text');
      return authorElement ? authorElement.textContent.trim() : 'Unknown';
    } catch {
      return 'Unknown';
    }
  }

  getCommentLikes(commentElement) {
    try {
      const likesElement = commentElement.closest('ytd-comment-thread-renderer, ytd-comment-renderer')
        ?.querySelector('#vote-count-middle');
      const likesText = likesElement ? likesElement.textContent.trim() : '0';
      return likesText === '' ? 0 : parseInt(likesText) || 0;
    } catch {
      return 0;
    }
  }

  async generateAllSummaries() {
    console.log('ü§ñ Generating all summary types...');
    
    this.summaries = {};
    
    // Generate different types of summaries
    const summaryTypes = ['insightful', 'funny', 'actionable', 'controversial'];
    const lengths = ['short', 'auto', 'detailed'];
    
    for (const type of summaryTypes) {
      this.summaries[type] = {};
      for (const length of lengths) {
        try {
          const summary = await this.getSummaryByType(type, length);
          this.summaries[type][length] = summary;
        } catch (error) {
          console.error(`Failed to generate ${type} ${length} summary:`, error);
          this.summaries[type][length] = `Failed to generate ${type} summary`;
        }
      }
    }
  }

  async getSummaryByType(type, length) {
    const data = {
      transcript: this.transcriptData,
      comments: this.commentsData,
      type: type,
      length: length,
      format: this.currentFormat,
      videoId: this.currentVideoId
    };

    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({
        action: 'summarizeAdvanced',
        data: data
      }, (response) => {
        if (response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.summary);
        }
      });
    });
  }

  formatAsQA(summary) {
    // Parse summary and format as Q&A
    const qaItems = this.extractQAFromSummary(summary);
    
    return `
      <div class="qa-format">
        ${qaItems.map((qa, index) => `
          <div class="qa-item">
            <div class="question">
              <span class="q-icon">Q</span>
              <span class="question-text">${qa.question}</span>
            </div>
            <div class="answer">
              <span class="a-icon">A</span>
              <div class="answer-content">
                ${qa.answer}
                ${qa.timestamps ? qa.timestamps.map(ts => 
                  `<span class="timestamp-highlight" data-time="${ts.time}">${ts.time} ${ts.text}</span>`
                ).join('') : ''}
              </div>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  formatAsTimestampedList(summary) {
    // Format as engaging sections with emoji bullets (no timestamps)
    const sections = this.extractEngagingSections(summary);
    
    return `
      <div class="engaging-list">
        ${sections.map(section => `
          <div class="summary-section">
            <h4 class="section-headline">${section.headline}</h4>
            <div class="section-content">
              ${section.points.map(point => `
                <div class="summary-point">
                  <span class="point-text">${point.text}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  extractQAFromSummary(summary) {
    // Simple Q&A extraction - in production this would be more sophisticated
    const lines = summary.split('\n').filter(line => line.trim());
    const qaItems = [];
    
    // Generate relevant questions based on summary type
    const questions = this.generateQuestionsForType(this.currentSummaryType);
    
    // Split summary into chunks for answers
    const chunks = this.splitSummaryIntoChunks(lines, questions.length);
    
    questions.forEach((question, index) => {
      const answer = chunks[index] || lines[index] || 'No specific information available.';
      const timestamps = this.extractTimestampsFromText(answer);
      
      qaItems.push({
        question,
        answer: answer.replace(/\d{1,2}:\d{2}/g, ''), // Remove timestamps from answer text
        timestamps: timestamps
      });
    });
    
    return qaItems;
  }

  extractEngagingSections(summary) {
    // Extract sections in the new format: "üé§ Section Header" followed by "üöÄ Insight text"
    const lines = summary.split('\n').filter(line => line.trim());
    const sections = [];
    let currentSection = null;
    
    lines.forEach(line => {
      const trimmedLine = line.trim();
      
      // Check if it's a section headline (starts with emoji followed by space and title)
      if (trimmedLine.match(/^[üé§üåêüí°üöÄüî•‚ö°Ô∏èüìàüéØüß†üí∞ü§ñüåü‚öñÔ∏èüîÆüõ†Ô∏è]\s+[A-Z]/)) {
        // New section headline
        if (currentSection) sections.push(currentSection);
        currentSection = {
          headline: trimmedLine,
          points: []
        };
      } else if (currentSection && trimmedLine.match(/^[üöÄüí∞üß†ü§ñüåêüî•‚ö°Ô∏èüìàüéØüí°üé§üåü‚öñÔ∏èüîÆüõ†Ô∏è]/)) {
        // This is an insight point starting with emoji
        currentSection.points.push({
          text: trimmedLine
        });
      } else if (!currentSection && trimmedLine.match(/^[üöÄüí∞üß†ü§ñüåêüî•‚ö°Ô∏èüìàüéØüí°üé§üåü‚öñÔ∏èüîÆüõ†Ô∏è]/)) {
        // Handle case where there are insights without section headers
        if (!currentSection) {
          currentSection = {
            headline: this.getHeadlineForType(this.currentSummaryType),
            points: []
          };
        }
        currentSection.points.push({
          text: trimmedLine
        });
      }
    });
    
    if (currentSection) sections.push(currentSection);
    
    // If no sections found, create default structure
    if (sections.length === 0) {
      sections.push({
        headline: this.getHeadlineForType(this.currentSummaryType),
        points: lines.filter(line => line.trim().length > 0 && line.match(/^[üöÄüí∞üß†ü§ñüåêüî•‚ö°Ô∏èüìàüéØüí°üé§üåü‚öñÔ∏èüîÆüõ†Ô∏è]/)).map(line => ({
          text: line.trim()
        }))
      });
    }
    
    return sections;
  }

  generateQuestionsForType(type) {
    const questionSets = {
      insightful: [
        "What are the key insights from this video?",
        "What are the main learning points?",
        "What deeper understanding can we gain?",
        "What are the implications discussed?"
      ],
      funny: [
        "What are the funniest moments in the video?",
        "What jokes or humorous observations are made?",
        "What entertaining elements stand out?",
        "What lighthearted content is included?"
      ],
      actionable: [
        "What specific actions can viewers take?",
        "What practical steps are recommended?",
        "What tools or methods are suggested?",
        "How can viewers implement these ideas?"
      ],
      controversial: [
        "What controversial points are raised?",
        "What debates or disagreements are discussed?",
        "What opposing viewpoints are presented?",
        "What might generate discussion or controversy?"
      ]
    };
    
    return questionSets[type] || questionSets.insightful;
  }

  getHeadlineForType(type) {
    const headlines = {
      insightful: 'Key Insights & Learnings',
      funny: 'Humorous Highlights',
      actionable: 'Action Items & Takeaways',
      controversial: 'Debate Points & Controversies'
    };
    
    return headlines[type] || 'Summary Points';
  }

  extractTimestampsFromText(text) {
    const timestampRegex = /(\d{1,2}:\d{2})/g;
    const matches = text.match(timestampRegex) || [];
    
    return matches.map(time => ({
      time: time,
      text: `Jump to ${time}`
    }));
  }

  splitSummaryIntoChunks(lines, numChunks) {
    const chunkSize = Math.ceil(lines.length / numChunks);
    const chunks = [];
    
    for (let i = 0; i < lines.length; i += chunkSize) {
      chunks.push(lines.slice(i, i + chunkSize).join(' '));
    }
    
    return chunks;
  }

  async getTimestampedSummary() {
    const data = {
      transcript: this.transcriptData,
      videoId: this.currentVideoId,
      type: 'timestamped'
    };

    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({
        action: 'summarizeTimestamped',
        data: data
      }, (response) => {
        if (response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.summary);
        }
      });
    });
  }

  async getSummary(transcript) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({
        action: 'summarize',
        transcript: transcript,
        videoId: this.currentVideoId
      }, (response) => {
        if (response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.summary);
        }
      });
    });
  }

  createSummaryContainer() {
    if (this.summaryContainer) return;

    // Find the video secondary info (below video)
    const secondaryInfo = document.querySelector('#secondary-inner') || 
                         document.querySelector('#secondary') ||
                         document.querySelector('#columns #secondary');
    
    if (!secondaryInfo) return;

    this.summaryContainer = document.createElement('div');
    this.summaryContainer.id = 'youtube-summarizer-container';
    this.summaryContainer.innerHTML = `
      <div class="summarizer-header">
        <div class="header-controls">
          <div class="dropdown-row">
            <div class="dropdown-control">
              <label>Summary Type</label>
              <select id="summary-type-select">
                <option value="insightful">Insightful</option>
                <option value="funny">Funny</option>
                <option value="actionable">Actionable</option>
                <option value="controversial">Controversial</option>
              </select>
            </div>
            
            <div class="dropdown-control">
              <label>Format</label>
              <select id="format-select">
                <option value="list">List</option>
                <option value="qa">Q&A</option>
              </select>
            </div>
            
            <div class="dropdown-control">
              <label>Length</label>
              <select id="length-select">
                <option value="short">Short</option>
                <option value="auto">Auto</option>
                <option value="detailed">Detailed</option>
              </select>
            </div>
          </div>
          
          <div class="action-row">
            <button id="transcript-btn" class="action-btn" title="Show/Hide Transcript">
              üìù Transcript
            </button>
            
            <button id="copy-btn" class="action-btn" title="Copy Summary">
              üìã
            </button>
            
            <div class="export-dropdown">
              <button id="export-btn" class="action-btn" title="Export Options">
                üì§ Export ‚ñº
              </button>
              <div id="export-menu" class="export-menu" style="display: none;">
                <div class="export-section">
                  <div class="export-section-title">Copy</div>
                  <button class="export-option" data-action="copy-link">Link</button>
                  <button class="export-option" data-action="copy-text">Text</button>
                </div>
                <div class="export-section">
                  <div class="export-section-title">Export</div>
                  <button class="export-option" data-action="export-txt">Txt</button>
                  <button class="export-option" data-action="export-doc">Doc</button>
                  <button class="export-option" data-action="export-pdf">PDF</button>
                  <button class="export-option" data-action="export-markdown">Markdown</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="summary-display-panel">
        <div id="summary-content">
          <div class="loading-summary">
            <div class="loading-spinner"></div>
            <span>Generating AI summary...</span>
          </div>
        </div>
      </div>
    `;

    // Insert at the top of secondary content
    secondaryInfo.insertBefore(this.summaryContainer, secondaryInfo.firstChild);

    this.attachEventListeners();
  }

  attachEventListeners() {
    // Summary Type dropdown
    const summaryTypeSelect = this.summaryContainer.querySelector('#summary-type-select');
    summaryTypeSelect.addEventListener('change', (e) => {
      this.currentSummaryType = e.target.value;
      console.log(`üé≠ Summary type changed to: ${this.currentSummaryType} - clearing cache`);
      // Clear cache to ensure new format generation
      chrome.runtime.sendMessage({ action: 'clearCache' });
      this.updateSummaryDisplay();
    });

    // Format dropdown
    const formatSelect = this.summaryContainer.querySelector('#format-select');
    formatSelect.addEventListener('change', (e) => {
      this.currentFormat = e.target.value;
      console.log(`üìã Format changed to: ${this.currentFormat} - clearing cache`);
      // Clear cache to ensure new format generation
      chrome.runtime.sendMessage({ action: 'clearCache' });
      this.updateSummaryDisplay();
    });

    // Length dropdown
    const lengthSelect = this.summaryContainer.querySelector('#length-select');
    lengthSelect.addEventListener('change', (e) => {
      this.currentLength = e.target.value;
      console.log(`üìè Length changed to: ${this.currentLength} - clearing cache to ensure new generation`);
      // Clear cache when length changes to ensure different lengths are generated
      chrome.runtime.sendMessage({ action: 'clearCache' });
      this.updateSummaryDisplay();
    });
    
    // Transcript button
    const transcriptBtn = this.summaryContainer.querySelector('#transcript-btn');
    
    transcriptBtn.addEventListener('click', () => {
      this.toggleTranscript();
    });

    // Copy button
    const copyBtn = this.summaryContainer.querySelector('#copy-btn');
    copyBtn.addEventListener('click', () => {
      this.copySummaryToClipboard();
    });

    // Export dropdown toggle
    const exportBtn = this.summaryContainer.querySelector('#export-btn');
    const exportMenu = this.summaryContainer.querySelector('#export-menu');
    
    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportMenu.style.display = exportMenu.style.display === 'none' ? 'block' : 'none';
    });

    // Close export menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.export-dropdown')) {
        exportMenu.style.display = 'none';
      }
    });

    // Export options
    const exportOptions = this.summaryContainer.querySelectorAll('.export-option');
    exportOptions.forEach(option => {
      option.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        this.handleExportAction(action);
        exportMenu.style.display = 'none';
      });
    });

    // Add timestamp click handlers (will be added dynamically)
    this.summaryContainer.addEventListener('click', (e) => {
      if (e.target.closest('.timestamp-highlight')) {
        const timeStr = e.target.closest('.timestamp-highlight').dataset.time;
        if (timeStr) {
          this.jumpToTime(timeStr);
        }
      }
    });
  }

  jumpToTime(timeString) {
    // Convert time string (e.g., "02:30") to seconds
    const parts = timeString.split(':').map(Number);
    let seconds = 0;
    
    if (parts.length === 2) {
      seconds = parts[0] * 60 + parts[1]; // MM:SS
    } else if (parts.length === 3) {
      seconds = parts[0] * 3600 + parts[1] * 60 + parts[2]; // HH:MM:SS
    }
    
    // Find YouTube video player and set time
    const video = document.querySelector('video');
    if (video) {
      video.currentTime = seconds;
      video.play();
      console.log(`üéØ Jumped to ${timeString} (${seconds} seconds)`);
    }
  }

  showLoadingState() {
    // Individual loading states are handled in createSummaryContainer
  }

  displayAdvancedSummary() {
    this.updateSummaryDisplay();
  }

  displayCommentsSummary() {
    const commentsDiv = this.summaryContainer.querySelector('#comments-summary');
    
    if (this.commentsData && this.commentsData.length > 0) {
      const topComments = this.commentsData.slice(0, 5);
      commentsDiv.innerHTML = `
        <div class="comments-list">
          ${topComments.map(comment => `
            <div class="comment-item">
              <div class="comment-author">@${comment.author}</div>
              <div class="comment-text">${comment.text}</div>
              <div class="comment-likes">${comment.likes} likes</div>
            </div>
          `).join('')}
        </div>
        <div class="comments-tldr">
          <p><strong>TLDR:</strong> ${this.generateCommentsTLDR()}</p>
        </div>
      `;
    } else {
      commentsDiv.innerHTML = '<p>No comments available for this video</p>';
    }
  }

  generateCommentsTLDR() {
    if (!this.commentsData) return "No comments to summarize";
    
    // Simple TLDR generation based on common themes
    const allText = this.commentsData.map(c => c.text).join(' ').toLowerCase();
    
    if (allText.includes('great') || allText.includes('amazing') || allText.includes('love')) {
      return "Viewers are generally positive about this content";
    } else if (allText.includes('question') || allText.includes('how') || allText.includes('help')) {
      return "Many viewers have questions and are seeking clarification";
    } else if (allText.includes('thanks') || allText.includes('helpful') || allText.includes('useful')) {
      return "Viewers find this content helpful and educational";
    } else {
      return "Mixed reactions and discussions in the comments";
    }
  }

  updateSummaryDisplay() {
    const summaryContent = this.summaryContainer.querySelector('#summary-content');
    
    if (this.summaries && this.summaries[this.currentSummaryType] && this.summaries[this.currentSummaryType][this.currentLength]) {
      const summary = this.summaries[this.currentSummaryType][this.currentLength];
      
      if (this.currentFormat === 'qa') {
        summaryContent.innerHTML = this.formatAsQA(summary);
      } else {
        summaryContent.innerHTML = this.formatAsTimestampedList(summary);
      }
    } else {
      summaryContent.innerHTML = '<div class="loading-summary"><div class="loading-spinner"></div><span>Loading summary...</span></div>';
    }
  }

  formatSummaryWithCategories(summary) {
    // Parse and format the summary into categories like the competitor
    const categories = this.extractCategories(summary);
    
    let html = `<div class="categorized-summary">`;
    
    categories.forEach(category => {
      html += `
        <div class="summary-category">
          <h4>${category.title}</h4>
          <div class="category-content">
            ${category.points.map(point => `<p>‚Ä¢ ${point}</p>`).join('')}
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    return html;
  }

  extractCategories(summary) {
    // Simple categorization - in a real app, this would be more sophisticated
    const lines = summary.split('\n').filter(line => line.trim());
    
    const categories = [];
    let currentCategory = null;
    
    lines.forEach(line => {
      if (line.includes(':') && !line.startsWith('‚Ä¢') && !line.startsWith('-')) {
        // Looks like a category header
        if (currentCategory) categories.push(currentCategory);
        currentCategory = {
          title: line.split(':')[0].trim(),
          points: []
        };
      } else if (currentCategory && (line.startsWith('‚Ä¢') || line.startsWith('-'))) {
        // Bullet point
        currentCategory.points.push(line.replace(/^[‚Ä¢\-]\s*/, ''));
      } else if (currentCategory) {
        // Regular content
        currentCategory.points.push(line);
      }
    });
    
    if (currentCategory) categories.push(currentCategory);
    
    // If no categories found, create default ones
    if (categories.length === 0) {
      categories.push({
        title: this.getCategoryTitle(),
        points: lines
      });
    }
    
    return categories;
  }

  getCategoryTitle() {
    switch(this.currentMode) {
      case 'insightful': return 'Key Insights';
      case 'funny': return 'Humorous Highlights';
      case 'actionable': return 'Action Items';
      case 'controversial': return 'Debate Points';
      default: return 'Summary';
    }
  }

  updateViewDisplay() {
    const mainDiv = this.summaryContainer.querySelector('#main-summary');
    const timestampDiv = this.summaryContainer.querySelector('#timestamped-summary');
    
    if (this.currentView === 'timestamps') {
      mainDiv.style.display = 'none';
      timestampDiv.style.display = 'block';
      this.displayTimestampedSummary();
    } else {
      mainDiv.style.display = 'block';
      timestampDiv.style.display = 'none';
    }
  }

  displayTimestampedSummary() {
    const timestampContent = this.summaryContainer.querySelector('.timestamp-content');
    
    if (this.summaries && this.summaries.timestamped) {
      timestampContent.innerHTML = this.formatTimestampedSummary(this.summaries.timestamped);
    } else {
      timestampContent.innerHTML = '<div class="loading-timestamps">Generating timestamped summary...</div>';
    }
  }

  formatTimestampedSummary(timestampedData) {
    if (typeof timestampedData === 'string') {
      // Parse timestamped summary string
      const lines = timestampedData.split('\n').filter(line => line.trim());
      return `
        <div class="timestamped-summary">
          ${lines.map(line => {
            if (line.includes('üí∞') || line.includes('üß†') || line.includes('‚ö°')) {
              const parts = line.split(' ');
              const time = parts.find(part => part.match(/\d{1,2}:\d{2}/));
              const content = line.replace(time || '', '').trim();
              return `
                <div class="timestamp-item" data-time="${time}">
                  <span class="timestamp-time">${time || '00:00'}</span>
                  <span class="timestamp-content">${content}</span>
                </div>
              `;
            }
            return `<p>${line}</p>`;
          }).join('')}
        </div>
      `;
    }
    
    return '<div class="no-timestamps">No timestamped data available</div>';
  }

  displayTranscript() {
    const transcriptDiv = this.summaryContainer.querySelector('.transcript-content');
    
    if (this.transcriptData) {
      // Format transcript with timestamps if available
      transcriptDiv.innerHTML = `
        <div class="full-transcript">
          <p><strong>00:00</strong> ${this.transcriptData.substring(0, 200)}...</p>
          <button class="expand-transcript">Show full transcript</button>
        </div>
      `;
    } else {
      transcriptDiv.innerHTML = '<p>Transcript not available for this video</p>';
    }
  }

  displayError(message) {
    if (!this.summaryContainer) return;
    const summaryContent = this.summaryContainer.querySelector('#summary-content');
    summaryContent.innerHTML = `
      <div class="summarizer-error">
        <span>‚ö†Ô∏è ${message}</span>
      </div>
    `;
  }

  // Copy and Export functionality
  copySummaryToClipboard() {
    const summaryText = this.getCurrentSummaryText();
    navigator.clipboard.writeText(summaryText).then(() => {
      this.showToast('üìã Summary copied to clipboard!');
    }).catch(err => {
      console.error('Failed to copy: ', err);
      this.showToast('‚ùå Failed to copy summary');
    });
  }

  getCurrentSummaryText() {
    if (!this.summaries || !this.summaries[this.currentSummaryType] || !this.summaries[this.currentSummaryType][this.currentLength]) {
      return 'No summary available';
    }
    
    const summary = this.summaries[this.currentSummaryType][this.currentLength];
    const videoTitle = document.querySelector('h1.ytd-watch-metadata')?.textContent || 'YouTube Video';
    const videoUrl = window.location.href;
    
    return `${videoTitle}\n\n${summary}\n\nSource: ${videoUrl}`;
  }

  handleExportAction(action) {
    const summaryText = this.getCurrentSummaryText();
    const videoTitle = document.querySelector('h1.ytd-watch-metadata')?.textContent || 'YouTube Video Summary';
    const cleanTitle = videoTitle.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').substring(0, 50);
    
    switch(action) {
      case 'copy-link':
        this.copyVideoLink();
        break;
      case 'copy-text':
        this.copySummaryToClipboard();
        break;
      case 'export-txt':
        this.downloadFile(summaryText, `${cleanTitle}.txt`, 'text/plain');
        break;
      case 'export-doc':
        this.exportAsDoc(summaryText, cleanTitle);
        break;
      case 'export-pdf':
        this.exportAsPDF(summaryText, cleanTitle);
        break;
      case 'export-markdown':
        this.exportAsMarkdown(summaryText, cleanTitle);
        break;
    }
  }

  copyVideoLink() {
    const videoUrl = window.location.href;
    navigator.clipboard.writeText(videoUrl).then(() => {
      this.showToast('üîó Video link copied to clipboard!');
    }).catch(err => {
      console.error('Failed to copy link: ', err);
      this.showToast('‚ùå Failed to copy link');
    });
  }

  downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    this.showToast(`üìÑ Downloaded ${filename}`);
  }

  exportAsDoc(content, title) {
    // Simple RTF format for .doc files
    const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}} \\f0\\fs24 ${content.replace(/\n/g, '\\par ')}}`;
    this.downloadFile(rtfContent, `${title}.doc`, 'application/msword');
  }

  exportAsPDF(content, title) {
    // For now, we'll create a simple HTML version that can be printed as PDF
    // In a full implementation, you'd use a PDF library
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
          h1 { color: #333; border-bottom: 2px solid #333; }
          .summary { white-space: pre-wrap; }
        </style>
      </head>
      <body>
        <h1>${title}</h1>
        <div class="summary">${content}</div>
        <script>window.print();</script>
      </body>
      </html>
    `;
    
    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    this.showToast('üñ®Ô∏è PDF preview opened - use browser print to save as PDF');
  }

  exportAsMarkdown(content, title) {
    const videoTitle = document.querySelector('h1.ytd-watch-metadata')?.textContent || 'YouTube Video';
    const videoUrl = window.location.href;
    
    const markdownContent = `# ${videoTitle}

${content}

---
**Source:** [${videoTitle}](${videoUrl})
**Generated:** ${new Date().toLocaleDateString()}
`;
    
    this.downloadFile(markdownContent, `${title}.md`, 'text/markdown');
  }

  showToast(message) {
    // Create and show a temporary toast notification
    const toast = document.createElement('div');
    toast.className = 'summarizer-toast';
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      z-index: 10000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s';
      setTimeout(() => {
        document.body.removeChild(toast);
      }, 300);
    }, 3000);
  }

  // Transcript functionality
  toggleTranscript() {
    const transcriptBtn = this.summaryContainer.querySelector('#transcript-btn');
    
    if (this.showingTranscript) {
      // Switch back to summary
      this.showingTranscript = false;
      transcriptBtn.innerHTML = 'üìù Transcript';
      transcriptBtn.classList.remove('active');
      this.updateSummaryDisplay();
    } else {
      // Switch to transcript
      this.showingTranscript = true;
      transcriptBtn.innerHTML = 'üìù Hide';
      transcriptBtn.classList.add('active');
      this.displayTranscriptInSummaryPanel();
    }
  }

  async displayTranscriptInSummaryPanel() {
    const summaryContent = this.summaryContainer.querySelector('#summary-content');
    
    try {
      let transcript = this.transcriptData;
      
      // If we don't have transcript data, try to extract it
      if (!transcript) {
        summaryContent.innerHTML = `
          <div class="loading-summary">
            <div class="loading-spinner"></div>
            <span>Loading transcript...</span>
          </div>
        `;
        
        transcript = await this.extractTranscript();
        this.transcriptData = transcript;
      }

      // Check if transcript is valid and is an array
      if (!transcript) {
        summaryContent.innerHTML = `
          <div class="summarizer-error">
            <span>‚ö†Ô∏è Transcript not available for this video</span>
            <p>This video may not have subtitles enabled or may be restricted.</p>
          </div>
        `;
        return;
      }

      // Debug: Log the transcript format
      console.log('üìù Transcript data received:', transcript);
      console.log('üìù Transcript type:', typeof transcript);
      console.log('üìù Is array:', Array.isArray(transcript));

      // Handle transcript format - should now be an array from getTranscriptSegments
      let transcriptArray = [];
      if (Array.isArray(transcript)) {
        transcriptArray = transcript;
        console.log('üìù Using transcript array directly');
      } else if (typeof transcript === 'string') {
        // If it's still a string (fallback), convert to segments
        console.log('üìù Converting string transcript to segments');
        const sentences = transcript.split(/[.!?]+/).filter(s => s.trim().length > 10);
        transcriptArray = sentences.slice(0, 50).map((sentence, index) => ({
          start: index * 8,
          text: sentence.trim(),
          index: index
        }));
      } else {
        console.error('üìù Unexpected transcript format:', transcript);
        throw new Error(`Transcript is not in expected format. Received: ${typeof transcript}`);
      }

      if (transcriptArray.length === 0) {
        summaryContent.innerHTML = `
          <div class="summarizer-error">
            <span>‚ö†Ô∏è No transcript content found</span>
          </div>
        `;
        return;
      }

      const transcriptHtml = transcriptArray.map((segment, index) => {
        console.log('üìù Processing segment:', segment);
        
        // Get time - should already be in seconds from getTranscriptSegments
        const startTime = segment.start || segment.startTime || segment.tStartMs || segment.time || (index * 8);
        
        // If startTime is very large, it might be in milliseconds
        const timeInSeconds = startTime > 3600 ? Math.floor(startTime / 1000) : startTime;
        const timeStr = this.formatTime(timeInSeconds);
        
        // Get text content
        const text = segment.text || segment.snippet || segment.segs?.[0]?.utf8 || `Segment ${index + 1}`;
        
        return `
          <div class="transcript-segment" data-start="${timeInSeconds}">
            <span class="transcript-time" data-time="${timeStr}">${timeStr}</span>
            <span class="transcript-text">${text}</span>
          </div>
        `;
      }).join('');

      summaryContent.innerHTML = `
        <div class="transcript-display">
          <h3 class="transcript-title">üìù Video Transcript</h3>
          <div class="transcript-segments">${transcriptHtml}</div>
        </div>
      `;

      // Add click handlers for transcript timestamps
      const timeElements = summaryContent.querySelectorAll('.transcript-time');
      timeElements.forEach(timeElement => {
        timeElement.addEventListener('click', () => {
          const timeStr = timeElement.dataset.time;
          this.jumpToTime(timeStr);
        });
      });

    } catch (error) {
      console.error('üìù Error displaying transcript:', error);
      console.error('üìù Error stack:', error.stack);
      console.error('üìù Transcript data that caused error:', transcript);
      
      summaryContent.innerHTML = `
        <div class="summarizer-error">
          <span>‚ö†Ô∏è Failed to load transcript</span>
          <p class="error-details">${error.message}</p>
          <p style="font-size: 12px; color: #656d76; margin-top: 8px;">
            Check browser console for detailed debug information.
          </p>
        </div>
      `;
    }
  }

  formatTime(seconds) {
    // Handle different input formats
    if (!seconds) return '00:00';
    
    // If seconds is a string, try to parse it
    if (typeof seconds === 'string') {
      seconds = parseFloat(seconds);
    }
    
    if (isNaN(seconds)) return '00:00';
    
    // If the number is very large, it might be in milliseconds
    if (seconds > 86400) { // More than 24 hours suggests milliseconds
      seconds = seconds / 1000;
    }
    
    seconds = Math.floor(seconds);
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
  }

  removePreviousSummary() {
    if (this.summaryContainer) {
      this.summaryContainer.remove();
      this.summaryContainer = null;
    }
    this.showingTranscript = false;
    this.transcriptData = null; // Clear old transcript data
  }
}

// Initialize the summarizer when the script loads
const summarizer = new YouTubeSummarizer();

